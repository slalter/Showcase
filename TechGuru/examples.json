{"set0": ["def fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\nresult = fibonacci(\"5\")", "async def fetch_data(url):\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            return await response.text()\n\nasync def parse_html(html):\n    soup = BeautifulSoup(html, 'html.parser')\n    return [element.text for element in soup.find_all('p')]\n\nasync def scrape_website(url):\n    html = await fetch_data(url)\n    return await parse_html(html)\n\nresult = asyncio.run(scrape_website('https://example.com'))", "class Node:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n\ndef insert(root, value):\n    if root is None:\n        return Node(value)\n    if value < root.value:\n        root.left = insert(root.left, value)\n    else:\n        root.right = insert(root.right, value)\n    return root\n\ndef search(root, value):\n    if root is None or root.value == value:\n        return root\n    if value < root.value:\n        return search(root.left, value)\n    return search(root.right, value)", "import threading\n\ndef multiply_matrices(matrix1, matrix2, result, row, col):\n    result[row][col] = sum(matrix1[row][i] * matrix2[i][col] for i in range(len(matrix2)))\n\ndef parallel_matrix_multiply(matrix1, matrix2):\n    result = [[0 for _ in range(len(matrix2[0]))] for _ in range(len(matrix1))]\n    threads = []\n\n    for i in range(len(matrix1)):\n        for j in range(len(matrix2[0])):\n            thread = threading.Thread(target=multiply_matrices, args=(matrix1, matrix2, result, i, j))\n            threads.append(thread)\n            thread.start()\n\n    for thread in threads:\n        thread.join()\n\n    return result\n\nA = [[1, 2], [3, 4]]\nB = [[5, 6], [7, 8]]\nresult = parallel_matrix_multiply(A, B)", "def memoize(func):\n    cache = {}\n    def wrapper(*args):\n        if args not in cache:\n            cache[args] = func(*args)\n        return cache[args]\n    return wrapper\n\n@memoize\ndef fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)", "def primes():\n    n = 2\n    while True:\n        if all(n % i != 0 for i in range(2, int(n**0.5) + 1)):\n            yield n\n        n += 1\n\nprime_gen = primes()\nnext_prime = next(prime_gen)", "class FileManager:\n    def __init__(self, filename):\n        self.filename = filename\n\n    def __enter__(self):\n        self.file = open(self.filename, 'r')\n        return self.file\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self.file.close()\n\nwith FileManager('example.txt') as file:\n    content = file.read()", "class CustomIterator:\n    def __init__(self, data):\n        self.data = data\n        self.index = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.index >= len(self.data):\n            raise StopIteration\n        value = self.data[self.index]\n        self.index += 1\n        return value\n\ndef process_items(iterator):\n    for item in iterator:\n        print(item.upper())\n\nmy_iterator = CustomIterator([1, 2, 3, \"four\", \"five\"])\nprocess_items(my_iterator)", "def transform(items, func):\n    return list(map(func, items))\n\nresult = transform([1, 2, 3], lambda x: x * 2)", "class Factory:\n    def create_product(self, product_type):\n        if product_type == \"A\":\n            return ProductA()\n        elif product_type == \"B\":\n            return ProductB()\n\nclass ProductA:\n    def operation(self):\n        return \"Product A\"\n\nclass ProductB:\n    def operation(self):\n        return \"Product B\"\n\nfactory = Factory()\nproduct = factory.create_product(\"A\")\nresult = product.operation()"]}